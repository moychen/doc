# 操作系统

![image-20240402223043911](images/操作系统/image-20240402223043911.png)

![image-20240402223006790](images/操作系统/image-20240402223006790.png)

![image-20240402223118424](images/操作系统/image-20240402223118424.png)

![image-20240402223302220](images/操作系统/image-20240402223302220.png)

## 中断与异常

## 进程线程模型

### 进程

​		进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单元，又称任务。

* 程序一次执行过程
* 是正在运行的程序的抽象
* 将一个 CPU 变换成多个虚拟的 CPU
* 系统资源以进程为单位分配，如内存、文件等，每个进程具有独立的地址空间
* 操作系统将 CPU 调度给需要的进程

#### 进程控制块（PCB）

PCB：Process Control Block

* 又称进程描述符、进程属性
* 操作系统用于管理控制进程的一个专门数据结构
* 记录进程的各种属性，描述进程的动态变化过程

PCB 是系统感知进程存在的唯一标志，进程与 PCB 是一一对应的。

进程表：所有进程的 PCB 集合。





### 线程



## CPU调度

## 同步机制

## 内存管理

​		对于通用计算机而言，存储层次至少应具有三级 ：最高层为CPU寄存器，中间为主存，最底层是辅存。在较高档的计算机中，还可以根据具体的功能分工，细划为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质等6层。

![image-20240406150949941](images/操作系统/image-20240406150949941.png)

### 地址重定位

​	为了保证 CPU 执行指令时可正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为**地址重定位**。

#### 逻辑地址

* 用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址。
* 不能使用逻辑地址在内存中读取信息。

#### 物理地址

* 内存中存储单元的地址，可直接寻址

#### 静态重定位

​		当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换。一般可由软件完成。

#### 动态重定位

​		在进程执行过程中进行地址变换，即逐条指令执行时完成地址转换。需要硬件部件支持，该硬件部件通常称为 MMU（Memory Management Unit）。

### 物理内存管理

![image-20240406115754537](images/操作系统/image-20240406115754537.png)

#### 分页存储管理

##### 基本概念

* 划分作业：把进程的逻辑地址空间按相同的等分因子划分为若干部分，称为页面（page）或页，从0顺序编号。
* 等分主存：把主存也按相同大小划分为若干存储块，称为页框（page frame），从0顺序编号，也称物理页面、页帧或内存块。
* 逻辑地址的表示：用数对（p,d）表示，p表示页号，d表示页内地址。
* 主存分配原则：以页框为单位，把主存分给作业进程，按进程所需的页数来进行分配，一个页面对应一个页框，逻辑上相邻的页，物理上不一定相邻。
* 页面尺寸的大小：典型的有 4K 或 4M。
* 页表：记录页号和页框号的对应关系，确定页面和页框对应关系的表，也称为页面变换表（PMT），包含的信息有：页号、页框号、状态。
* 地址转换（硬件支持）：CPU取到逻辑地址，自动划分为页号和页内地址，用页号查页表，得到页框号，再与页内偏移地址拼接成为物理地址。
* 作业调度程序调入作业时，系统为其创建页表，撤销作业时清除页表。
* 页表基址寄存器：用于指出当前运行进程的页表起始地址和页表长度。
* 容易产生内碎片：内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间。

##### 动态地址变换

###### 高速页面变换寄存器

**动态地址变换的不足：**

​		因为页表是存放在内存中的，CPU要存取一个数据，需访问主存两次。第一次：访内存中的页表，找到该页的的物理块号，将此块号与页内地址拼结形成物理地址；第二次：真正访问该物理地址，存取其中的内容。这样就把程序的执行速度降低一倍。为了提高存取速度，在地址变换机构中增设一组寄存器，用来存放页表，其速度比内存表的查找要快一到两个数量级。
**做法：**

​		为了实现从作业地址空间到物理地址空间的变换，可采用硬件的高速寄存器来实现。因为任一时刻在处理机中只有一个作业在执行，所以只需一组高速寄存器就可满足要求。假定页面大小为 4 KB， 那么对于 100 KB的作业来说， 就需要 25 个高速寄存器。由于高速寄存器的成本高， 所以它适用于地址空间小的作业。如果系统所接受的作业都在 64 KB以下， 那么只需要 16 个寄存器就够了。在多道程序环境下，当处理机把控制转移到另一新作业时，应保存原作业的寄存器内容并重置相应的新作业的寄存器内容(即存储块号)。
**问题：**

作业过大时寄存器个数过多，成本高。

###### 联想存储器

​		动态地址变换速度慢，高速页面变换寄存器成本高。为控制成本且提高速度，可引入一定数量的寄存器存放页表（部分），并且使在寄存器查找到的概率达到90%左右。把存放在高速缓冲寄存器中的页表叫快表，这个高速缓冲寄存器又叫联想存贮器。存放的是当前正在运行的作业PMT中最常用的部分页号和相应的块号。

查找时双管其下，快表和 PMT 表的查找同时进行。

##### 算法

```
1. 作业表（JT）：整个系统一张，每个作业对应一个条目。
             包括：作业号，页表长度，起始地址，状态。
2. 存储分块表（MBT）：整个系统一张，每个表目对应一个存储块。
3. 页面变换表（PMT）：每个作业一张，有多少页面对应多少条目，包括页号、块号。
```

<figure>
<img src="images/操作系统/image-20210326161815804.png" width=300/>
<img src="images/操作系统/image-20210326161909273.png" width=300/>
</figure>
##### 优缺点

```
1. 采用动态地址变换会增加计算机成本并降低处理机的速度。
2. 各种表格要占用一定容量的主存空间，而且还要花费一部分处理机时间用来建立和管理这些表格。
3. 虽然说碎片消除了，但每个作业的最后一页一般都有不能充分利用的空白区。 
4. 存储扩充问题仍未得到解决。 
```

#### 分段存储管理

##### 基本概念

* 用户进程地址空间：按程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名。
* 内存空间被动态划分为若干长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定。
* 内存分配（规则）：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻。
* 逻辑地址的表示：用数对（p,d）表示，p表示段号，d表示段内地址。
* 段表：每项记录了段号、段首地址和段长度之间的关系，每个进程一个段表存放在内存。
* 地址转换（硬件）：CPU 取到逻辑地址（包含段号和段内地址），用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址。
* 段表基址寄存器：用于指出当前运行进程的段表起始地址。

#### 分段与分页的异同

**相同点：**

```
均采用离散方式分配内存，主存利用率高；
都要通过地址变换部件实现地址变换；
```

**不同点：** 

```
页是信息的物理单位，分页的目的是提高主存利用率；段是信息的逻辑单位，它含有一组完整的信息，分段的目的是更好地满足用户的需求。
页的大小固定，由系统确定；段的长度不固定，段的长度受制于程序大小；
页式管理其地址空间是一维的，L→ ( p,d )；段式管理地址是二维的，直接用（ s,w ）。
```

#### 段页式存储管理

##### 基本概念

* 用户进程划分：先按段划分，每一段再按页面划分
* 逻辑地址：包含段号、页号、页内地址
* 内存划分：同页式存储管理方案
* 内存分配：以页为单位进行分配
* 段表：记录每一段的页表起始地址和页表长度
* 页表：记录了逻辑页号和页框号的对应关系，每一段有一张页表，一个进程有多个页表
* 空闲区管理和内存分配、回收：同页式管理
* 地址转换（硬件支持）：CPU 取到逻辑地址（包含段号和段内地址），用段号查段表，得到页表的起始地址和长度，再将段内地址划分为页号和页内地址，再根据页号查页表，得到页框号，再与页内地址拼接成为物理地址。

#### 内存不足时如何管理

##### 内存紧缩技术

在内存移动程序，将所有小的空闲区（外碎片）合并为较大的空闲区。例如：可变分区中存在的外碎片问题。

##### 覆盖技术（overlaying）

覆盖技术主要用于早期的操作系统。

* 主要解决程序大小超过物理内存总和的问题
* 程序执行过程中，程序的不同部分在内存中相互替代
  * 按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域
  * 要求程序各模块之间有明确的调用结构
* 程序员声明覆盖结构，操作系统完成自动覆盖

##### swap（交换技术）

​		交换技术被广泛地运用于早期的小型分时系统的存贮管理中。所谓交换，就是系统根据需要把主存中暂时不运行的某个(或某些)作业部分或全部移到外存，而把外存中的某个(或某些)作业移到相应的主存区，并使其投入运行。所以，交换技术也叫对换或滚进滚出（roll-in,roll-out）。也有的系统叫挂起调度或中级调度。被换出到外存的程序只是临时被剥夺了对内存的使用权，过一段时间，还必须换入内存运行。因此，交换是一种用时间换空间的技术。 

**进程哪些内容要交换到磁盘**

运行时创建或修改的内容：栈和堆

**交换区**

一般系统会指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问。

**交换的时机**：

* 只要不用就换出（很少再用）
* 作业的进程用完时间片或等待输入输出
* 作业要求扩充存储而得不到满足时
* 考虑进程的各种属性；不应换出处于等待 I/O 状态的进程

**进程空间增长的困难和解决**

![image-20240406121600726](images/操作系统/image-20240406121600726.png)

##### 虚拟存储技术（virtual memory）

#### 请求分页存储管理/虚拟页式存储管理

```
一、核心：
      解决内存资源不足，实现存储扩充。
二、请求分页原理：
1. 思想：
    一作业执行之前不需将全部地址空间一次装入，动态申请，动态装入。
 2. 问题：
     在请求分页存储管理中，必须解决如下几个问题：
     ( 1 ) 如果一个作业不把它的整个地址空间同时全部装入主存，那么该作业能否开始运行并运行一段时间?
         a.作业在运行期间的各个阶段，多数作业只使用全部地址空间的一部分。例如，用户编制的错误处理程序仅当程序出错时才会用到。
     又如多数作业在运行中划分为几个阶段：输入、计算、输出。在某一阶段中，各个程序可以不同时进入主存。
         b.程序的局部性。顺序执行的指令和线性结构的数据(如数组)，它们通常被限定在某一连续区域。一旦某一位置被访问后，那么它附近的位置很快也会被访问
     ( 2 ) 在作业运行了一段时间后，必然要访问到没有装入的页面，也就是说，要访问的虚页不在实存。那么，这个问题系统是怎样发现的呢?
         在PMT中增加一个状态位 规定该位为 0 表示该页已装入主存；该位为1表示该页不在主存。当地址变换机构检测到虚页的状态位为1时，    表示该页不在主存，规定由硬件产生缺页中断，转入中断处理程序，虽然这不是用户程序的错误，但它是属于程序中断。
     ( 3 ) 如果系统已经发现某虚页不在实存，就应将其装入实存。现在的问题是从何处装入，装入到何处，如果实存空间已满怎么办?
         当发现虚页不在实存时， 引起缺页中断，利用中断处理程序完成该页的装入。中断处理程序将所需页面装入实存后，修改PMT的状态位，后重新执行该指令。访问到不在内存中的虚页时，从磁盘装入（此时需建立一张辅助页表，指出对应关系）；主存有空闲时直接装入；主存满时必须淘汰某些旧页（若修改过，必须先写入主存；若未修改，辅存副本已存在，直接淘汰）。 
```

##### 缺页中断及其处理

<img src="images/操作系统/image-20210326174726476.png" alt="image-20210326174726476" style="zoom:67%;" />

##### 抖动（颠簸）

入页：将某页从辅存调入主存；

出页：将某页从主存移至辅存；

抖动（颠簸）：虚存中，页面在内存与磁盘之间频繁调度，使得调度页面所需的时间比进程实际运行的时间还多，这样导致系统效率急剧下降，这种现象称为颠簸或抖动。

抖动的弊端：浪费大量的CPU时间。

抖动的原因：页面置换算法选择不当。

##### 页面置换算法

最佳置换算法 → 先进先出 → 第二次机会 → 时钟算法 → 最近未使用 → 最近最少使用 → 最不经常使用 → 老化算法 → 工作集 → 工作集时钟

**最佳置换算法（OPTimal）**

 思想：淘汰那些永远不用（至少长时间不用）的页面（置换以后不再需要的或最远的将来才会用到的页面）。
 理由：不会产生颠簸。
 特点：降低缺页率。
 不足：理论上成立，需采用预调思想，实现困难，可以作为一种标准用来衡量其他算法的性能。

**先进先出算法( First In First Out )**

思想：先淘汰那些驻留在主存时间最长的页面，即先进入主存的页面先被淘汰。
理由：最早调入主存的页面，其不再被访问的可能性最大。
特点：简单，容易实现；不足是进入早者，既使常用也必须淘汰。
实现：设分配给一个作业的实页数为m，则只需建立一个由m个元素组成的队列表和一个替换指针即可。 

**最近最久未用置换算法LRU(Least Recently Used)**

思想：先淘汰那些最近长时间未使用的页面。
理由：新近访问的页面，再被访问的概率高，久未访问的页面，再被访问的概率低。
实现：记录每一页面最后一次访问后的时间间隔t，淘汰t最大者。
特点：适合各类程序；
            实现困难    软件实现：系统开销大（占用 CPU 时间）。
                                硬件实现：成本高。

**最近最久不常用置换算法LFU(Least Frequently Used)**

 思想：先淘汰那些最近一段时间内使用次数少的页面。
 理由：一段时间内较少访问的页面，再被访问的概率低，一段时间内访问频繁的页面，再被访问的概率高。
 实现：记录每一页面一段时间的使用次数，淘汰时选择频率最小者。
 特点：适合各类程序；
             实现困难    软件实现：系统开销大（占用CPU时间）。
                                 硬件实现：成本高。

**LRU近似算法**

思想：设置”引用位”，系统周期性地将该位清“0”，在时间T内，访问过的页面该位置“1”，若需置换，则选取引用位为“0”者淘汰。
特点：算法简单，易于实现。
问题：T的大小确定困难。太大时几乎全“1”，太小为“0”者过多。

##### 性能分析

​		请求页式存储管理消除了对主存大小的限制，能使更多的作业按多道方式运行，从而提高系统效率，但缺页中断对页面的调入调出，会使CPU付出相当多的代价。为了尽可能地减少缺页中断的次数，应从程序设计的质量，页面的大小，主存的容量以及页面置换算法等几方面来考虑。
**影响缺页中断的因素：**

```
1. 程序设计的质量 
局部性原理(principle of locality)：
指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。表现为：
    时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；
    空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内。
局部化程度越高越好，可集中于几个页面处理，减少缺页中断。

2. 页面大小的选择
规律：一般缺页中断率与页面尺寸成反比。但页面尺寸却不能一味地求大，它一般在0.5KB~4KB之间。
特点：因为页面大时，页表较小，占空间少，查表速度快，缺页中断次数少，但页面调度时间长，页内碎片较大。页面小时，恰恰相反。

3. 主存容量大小
引入虚拟存储，作业调入一部分即可运行，提高多道效率，实际上是低效的。即分配给作业的内存太少，引起颠簸。
4. 页面调度算法选择
页面调度算法选择不尽合理。页面调度算法不合理导致抖动。是指一段时间里，页面在内存与外存之间频繁地调度或换入换出，以至于系统用于调度页面所需要的时间比进程实际运行所占用的时间还要多。
```

主存大小和调度算法均引起抖动，抖动是由于缺页中断率很高而引起的一种坏现象，它将严重影响系统的效率，甚至可能使系统全面崩溃。

##### 优缺点

**优点：**

```
它提供了大容量的多个虚拟存储器，作业地址空间不再受实存容量的限制；
更有效地利用了主存，一个作业的地址空间不必全部同时都装入主存，只装入其必要部分，其它部分根据请求装入，或者根本就不装入(如错误处理程序等)；
更加有利于多道程序的运行， 从而提高了系统效率；
方便了用户，特别是大作业用户。 
```

**缺点：**

```
为处理缺页中断，增加了处理机时间的开销， 即请求分页系统是用时间的代价换取了空间的扩大；
可能因作业地址空间过大或多道程序道数过多以及其它原因而造成系统抖动；
为防止系统抖动所采取的各种措施会增加系统的复杂性。
```

### 其他技术

#### MMAP

进程通过一个系统调用（mmap）将一个文件（或部分）映射到其虚拟地址空间的一部分，访问这个文件就象访问内存中的一个大数组，而不是对文件进行读写。

* 在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时，页面才会被每次一页的读入，磁盘文件则被当作后备存储。

* 当进程退出或显式地解除文件映射时，所有被修改页面会写回文件

#### 写时拷贝		

![image-20240406215546250](images/操作系统/image-20240406215546250.png)

### 缓存

![image-20211116154101003](images/操作系统/image-20211116154101003.png)

![image-20211116154524501](images/操作系统/image-20211116154524501.png)

![image-20211116154511660](images/操作系统/image-20211116154511660.png)

![image-20211116155007200](images/操作系统/image-20211116155007200.png)

![image-20211116155054431](images/操作系统/image-20211116155054431.png)

## 文件系统

## IO 管理

