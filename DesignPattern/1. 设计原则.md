# 设计模式基本原则

## 1. 依赖倒置原则（DIP）

依赖倒置原则 (Dependency Inversion Principle, DIP)要求：

* 抽象（实现稳定不变）不应该依赖于实现细节（变化），实现细节应当依赖于抽象（实现稳定不变）。换言之，要针对接口编程，而不是针对实现编程，依赖于抽象（接口），而不依赖于具体实现（类），针对接口编程。框架和实现层向中间层（协议层/抽象层）靠拢
* 高层模块（稳定）依赖于底层模块（变化），二者都应依赖于抽象（稳定）。



## 2. 开闭原则（OCP）

开闭原则（Open-Closed Principle）要求：

* 对扩展开放，对修改关闭。即软件应该尽量在不修改原有代码的情况下进行扩展。
* 类的改动应该是通过扩展代码来实现而不是修改源代码。



 ## 3. 单一职责原则（SRP)

单一职责原则（Single Responsibility Principle）要求：

* 一个类只负责一个功能领域中的相应职责，或者定义为：就一个类而言，应该只有一个引起它变化的原因。
* 变化的方向隐含着类的责任

​		一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。



## 4. 里氏代换原则（LSP）

里氏代换原则（Liskov Substitution Principle）要求：

* 所有引用基类（父类）的地方必须能透明地使用其子类的对象。
* 继承表达类型抽象。

   里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。
**

​    里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。



## 5. 接口隔离原则（ISP）

接口隔离原则（Interface Segregation Principle）要求：

* 使用多个专门的接口，而不使用单一的总接口，即客户程序不应该依赖那些它不需要的接口。
* 接口应该小而完备。

​		根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的 “接口” 往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface.



## 6. 迪米特法则（LoD）

迪米特法则（Law of Demeter）要求：

* 一个软件实体应当尽可能少地与其他实体发生相互作用。

​    	一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统系统的可维护性。例如一个程序中，各个模块之间相互调用通常会提供一个统一的接口来实现，这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用（黑盒原理）。



