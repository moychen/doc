# C/C++面试题
## 基础知识
### 指针与引用的区别
>* 指针也是一种变量，只是保存的是变量的地址，而引用是变量一种别名。
>* 在C＋＋里，引用应被初始化，初始化后不能修改。但指针可以是未初始化的指针（不过空指针合法但危险）。
>* 不存在指向空值的应用，而指针可以为NULL。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空
>* 指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变。

以下情况下应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。
当重载某个操作符时，应该使用引用。最普通的例子是操作符[]。这个操作符典型的用法是返回一个目标对象，其能被赋值。

### 面向对象的三个特点
准确的来说，面向对象应该有四个特点：抽象、封装、继承和多态。
多态指为指为不同数据类型的实体提供统一的接口，能够依据对象所属类别，引发对应类别的方法，而有不同的行为。

### 早绑定和晚绑定

早绑定又称编译期绑定，晚绑定又称运行时绑定。

>* 静态类型：对象在声明时采用的类型，在编译期既已确定
>* 动态类型：通常指一个指针或引用目前所指对象的类型,是在运行期决定的
>* 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型,发生在编译期
>* 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期

在C++中，非虚函数一般都是静态绑定，而虚函数都是动态绑定(如此才可实现多态性)。

**结论：**
>* 如果基类A中的func函数不是虚函数,无论哪个指针对func的调用都是在定义时的静态类型决定，早在编译期确定了.
>* 同样空指针也能调用非虚函数而不报错，所以要做空指针检查,因此静态绑定不能实现多态。
>* 如果基类中的func函数是虚函数，那所有的调用都要等到运行是根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失，但实现了多态。
>* 引用同样适用。

**建议：**
***绝对不要重新定义继承而来的非虚函数,因为这样导致函数调用由对象声明的静态类型确定了，而和对象本身脱离了关系，没有多态，这也将给程序留下预知的隐患和莫名奇妙的BUG.***

***在动态绑定中，要注意默认参数的使用，当缺省参数和virtual函数一起使用时，一定要谨慎。绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数则是动态绑定.***

### 静多态和动多态

静多态又称编译期多态，动多态又称运行时多态。

多态指为指为不同数据类型的实体提供统一的接口，能够依据对象所属类别，引发对应类别的方法，而有不同的行为。
**编译期多态**
编译期多态主要是通过模板来实现的，又称泛型编程。
**优点:**
>* 它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。
>* 在编译器完成多态，提高运行期效率。 
>* 具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。

**缺点**
>* 程序可读性降低，代码调试带来困难。 
>* 无法实现模板的分离编译，当工程很大时，编译时间不可小觑。 
>* 无法处理异质对象集合。

 **运行时多态**
运行时多态是通过类继承机制和虚函数机制来实现的。所谓虚函数机制，主要是父类对虚函数的定义和实现，以及子类对虚函数的实现，然后通过用子类对象初始化父类引用或者将子类对象地址赋值给父类对象的指针。
**优点:**
>* OO设计中重要的特性，对客观世界直觉认识。
>* 能够处理同一个继承体系下的异质类集合。

**缺点:**
>* 运行期间进行虚函数绑定，提高了程序运行开销。
>* 庞大的类继承层次，对接口的修改易影响类继承层次。
>* 由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。
>* 虚表指针增大了对象体积，类也多了一张虚函数表，当然，这是理所应当得付出的资源消耗，列为缺点有点勉强。

### 虚析构函数的作用
一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。使用虚函数的目的是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。

### extern "C"的作用
extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的一些规则进行编译，而不是C++的。比如C++和C的函数签名是不一样的，C++函数签名包括参数类型不单单是函数名。

### volitale关键字的作用
Volatile是易变的意思，编译器在编译时期可能不能获取变量是否被多个线程或者进程修改的信息。这时候一个变量是否在两次“读操作”之间发生改变，编译器肯定无法确定。然而编译优化的技术针对一般的变量都会做出优化，例如：
```C
int a=0;
int b=a;
int c=a+1;
```
编译器极可能把a放在寄存器中，供b,c的计算使用。更有甚者，编译器确定a的值是0，会直接计算出b=0，c=1！如果在实际运行中a的值被其他线程修改，这么做就改变了代码的语意。

**使用格式：**
```C
volatile int a;//这里对a是否初始化已经不再重要了
```
为了消除这种问题，使用volatile关键字告诉编译器每次访问a的时候都需要读内存，而不对其优化。

### mutable



### 动态库与静态库的区别，动态库链接的方法

静态库和动态库区别来自链接阶段如何处理库、链接成可执行程序。分别称为静态链接方式、动态链接方式。
#### 静态库
之所以称为静态库，是因为在链接阶段会将会变生成的目标文件.o与引用到的库一起打包到可执行文件中，整个函数库的所有数据都会被整合进目标代码中。
静态库的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进可执行文件了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译，而且体积也较大。
Linux下静态库的命名规范：lib + your_library_name + .a。lib为前缀，中间静态库名，“.a”是后缀。
**创建：**
ar -crv libstaticmath.a StaticMath.o ...
ar命令的详细用法见google。

**使用**
g++ TestStaticLibrary.cpp -L ../StaticLibrary -lstaticmath
>* -L: 表示要连接的库所在目录
>* -l: 指定链接时需要的动态库，编译器查找动态链接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a或者.so来确定库的名称。

#### 动态库
动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。**不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例**，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，**增量更新**。如果静态库更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，**全量更新**。
动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。而且如果多个应用程序都要使用同一函数库，动态库就非常适合，可以减小应用程序的体积。
**创建**
g++ -shared -fPIC -o libdynmath.so lib -c DynamicMath.cpp
>* -fpic 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。
>* -shared 生成动态链接库

**使用**
g++ TestDynamicLibrary.cpp -L../DynamicLibrary -ldynmath
此时还不能立即./out，因为在动态函数库使用时，会查找/usr/lib /lib目录下的动态函数库，而此时我们生成的库不在里边。
这个时候有好几种方法可以让他成功运行： 
>* 最直接最简单的方法就是把libaddsub.so拉到/usr/lib 或/lib中去。

>* 还有一种方法,假设libaddsub.so在/home/linux/addsub
>  export LD_LIBRARY_PATH=/home/linux/addsub：$LD_LIBRARY_PATH

>* 另外还可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig。/etc/ld.so.conf是非常重要的一个目录，里面存放的是链接器和加载器搜索共享库时要检查的目录，一般是从/usr/lib或/lib中读取的，所以想要顺利运行，我们也可以把我们库的目录加入到这个文件中并执行/sbin/ldconfig。

#### 动态库的链接方法
**编译时动态链接**
这种用法的前提是在编译之前已经明确知道要调用DLL中的哪几个函数，编译时在目标文件中只保留必要的链接信息，而不含DLL函数的代码；当程序执行时，调用函数的时候利用链接信息加载DLL函数代码并在内存中将其链接入调用程序的执行空间中(全部函数加载进内存），其主要目的是便于代码共享。（动态加载程序，处在加载阶段，主要为了共享代码，共享代码内存）

**运行时动态链接**
这种方式是指在编译之前并不知道将会调用哪些DLL函数，完全是在运行过程中根据需要决定应调用哪个函数，将其加载到内存中（只加载调用的函数进内存），并标识内存地址，其他程序也可以使用该程序，并用LoadLibrary和GetProcAddress动态获得DLL函数的入口地址。（dll在内存中只存在一份，处在运行阶段）

### pkg_config的作用



### C++ explicit的作用
This keyword is a declaration specifier that can only be applied to in-class constructor declarations. Constructors declared **explicit** will not be considered for implicit conversions. For example:

```C++
class X {
public:
   explicit X(int);      //legal
   explicit X(double) {   //legal
      // ...
   }
};

explicit X::X(int) {}      //illegal
```

An explicit constructor cannot take part in implicit conversions. It can only be used to explicitly construct an object. For example, with the class declared above:

```C++
void f(X) {}
void g(int I) {
   f(i);      // will cause error
}
void h() {
   X x1(1);      // legal
}
```

The function call `f(i)` fails because there is no available implicit conversion from **int** to `X`.

**Note:**   It is meaningless to apply **explicit** to constructors with multiple arguments, since such constructors cannot take part in implicit conversions.

### 对make和cmake的理解
make主要依赖makefile这个文件，makefile中的内容主要包含三种：
目标文件、依赖规则、生成规则。

### static和const关键字
>* static变量存储在静态存储区，生命周期为整个程序的整个运行期。
>* static关键字限制了变量的作用域，静态全局变量只在定义该变量的源文件内有效，而在其他源文件不能使用它。非静态全局变量在声明了该变量的CPP文件或包含该变量声明头文件的CPP文件中都能使用。
>* C++类中声明的静态函数和静态变量，只属于类，与实例无关。

>* const变量存放在常量区
>* const关键字修饰的变量是只读的

## STL相关知识
### vector和list的区别



### 迭代器失效
**迭代器失效有两个层面的意思:**
>* 无法通过迭代器++,--操作遍历整个stl容器。记作: 第一层失效。
>* 无法通过迭代器存取迭代器所指向的内存。 记作: 第二层失效。

使用STL时，迭代器失效是一个很重要的问题，也是一个非常需要注意的地方，
**vector**
>* 插入操作如果导致vector扩容，所有迭代器均失效。
>* 删除操作，会导致当前迭代器及以后所有迭代器失效。

**dequeue**
>* 增加任何元素都将使deque的迭代器失效。
>* 在deque的中间删除元素将使迭代器失效。
>* 在deque的头或尾删除元素时，只有指向该元素的迭代器失效。

**list/set/map**
>* 删除时，指向该删除节点的迭代器失效

